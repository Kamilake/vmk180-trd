From 3d554ed53f56d22230cc7ed6c6fce5f3c70d7ce9 Mon Sep 17 00:00:00 2001
From: thippesw <thippesw@xilinx.com>
Date: Thu, 12 Aug 2021 02:50:49 -0600
Subject: [PATCH] Added DMA import support and command line options

---
 drivers/misc/xilinx_pci_endpoint.c | 160 +++++++++++++++++++++++++++--
 1 file changed, 149 insertions(+), 11 deletions(-)

diff --git a/drivers/misc/xilinx_pci_endpoint.c b/drivers/misc/xilinx_pci_endpoint.c
index 06b9ebabbac4..92874f54f637 100644
--- a/drivers/misc/xilinx_pci_endpoint.c
+++ b/drivers/misc/xilinx_pci_endpoint.c
@@ -66,14 +66,18 @@
 #define PCIEP_READ_TRANSFER_CLR    0x28
 #define PCIEP_READ_BUFFER_HOST_INTR  0x2c
 #define PCIEP_WRITE_TRANSFER_CLR  0x30
+#define PCIEP_KERNEL_NAME  0x3c
 
-#define PCIRC_READ_FILE_LENGTH     0x40
-#define PCIRC_READ_BUFFER_TRANSFER_DONE 0x44
-#define PCIRC_WRITE_BUFFER_TRANSFER_DONE 0x48
-#define PCIRC_KERNEL_MODE	      0x4c
+#define PCIRC_READ_FILE_LENGTH     		0x40
+#define PCIRC_READ_BUFFER_TRANSFER_DONE 	0x44
+#define PCIRC_WRITE_BUFFER_TRANSFER_DONE 	0x48
+#define PCIRC_PID_SET 				0x4c
+#define PCIRC_KERNEL_MODE	      		0x60
 #define PCIRC_FILTER_TYPE         0x50
 #define PCIRC_RAW_RESOLUTION      0x54
-#define PCIRC_USECASE_MODE        0x58
+#define PCIRC_FORMAT_SET        0x58
+#define PCIRC_UCASE_SET       0x5c
+#define PCIRC_SET_FPS        0x64
 #define PCIRC_READ_BUFFER_TRANSFER_DONE_INTR 0x68
 #define PCIRC_WRITE_BUFFER_TRANSFER_DONE_INTR 0x6c
 #define PCIRC_HOST_DONE_INTR     0x70
@@ -93,13 +97,16 @@
 #define SET_WRITE_TRANSFER_DONE   0x7
 #define CLR_WRITE_TRANSFER_DONE   0x8
 #define GET_RESOLUTION            0x9
-#define GET_MODE                  0xa
+#define GET_HDMI_PID              0xa
 #define GET_FPS                   0xb
 #define GET_FORMAT                0xc
 #define GET_FILTER_TYPE           0xd
 #define ALLOC_DMA_BUFF            0xe
 #define RELEASE_DMA_BUFF          0xf
 #define DIRECT_COPY               0x1a
+#define PCIE_DMABUF_IMPORT        0x1b
+#define GET_KERNEL_NAME        	  0x1c
+#define GET_USE_CASE        	  0x1d
 
 #define WIDTH_SHIFT               0x0
 #define WIDTH_MASK                0xFFFF
@@ -159,6 +166,30 @@
 #define _PGPROT_NONCACHED(vm_page_prot)    pgprot_noncached(vm_page_prot)
 #endif
 
+struct pcie_dmabuf_mem {
+	int dbuf_fd;
+	int flag;
+	struct dma_buf *dbuf;
+	struct dma_buf_attachment *dbuf_attach;
+	struct sg_table *sgt;
+	enum dma_data_direction dir;
+	struct list_head list;
+};
+
+enum pcie_dmabuf_dir {
+        PCIE_DMABUF_DIR_BIDIR    = 1,
+        PCIE_DMABUF_DIR_TO_DEV   = 2,
+        PCIE_DMABUF_DIR_FROM_DEV = 3,
+        PCIE_DMABUF_DIR_NONE     = 4,
+};
+
+struct pcie_dmabuf_args {
+        __s32   dbuf_fd;
+        __s32   flag;
+        __u64   dma_addr;
+        __u64   size;
+        __u8    dir;
+};
 
 
 static DEFINE_IDA(pciep_device_ida);
@@ -435,6 +466,101 @@ static int pciep_mmap(struct dma_buf *dmabuf,
 	return dma_mmap_coherent(this->dma_dev, vma, virt,
 				 phys, this->alloc_size);
 }
+static int pciep_dmabuf_import(struct pciep_driver_data *this,char __user *user_args){
+	printk("%s \n",__func__);
+	struct pcie_dmabuf_args args;
+	struct pcie_dmabuf_mem *dbuf_mem;
+	struct dma_buf *dbuf;
+	struct dma_buf_attachment *dbuf_attach;
+	enum dma_data_direction dir;
+	struct sg_table *sgt;
+	long ret;
+
+	if (copy_from_user(&args, user_args, sizeof(args))) {
+		ret = -EFAULT;
+		dev_err(this->dma_dev, "failed to copy from user\n");
+		goto err;
+	}
+	
+if (args.flag ==1){
+	dbuf = dma_buf_get(args.dbuf_fd);
+	if (IS_ERR(dbuf)) {
+		dev_err(this->dma_dev, "failed to get dmabuf\n");
+		return PTR_ERR(dbuf);
+	}
+
+	dbuf_attach = dma_buf_attach(dbuf, this->dma_dev);
+	if (IS_ERR(dbuf_attach)) {
+		dev_err(this->dma_dev, "failed to attach dmabuf\n");
+		ret = PTR_ERR(dbuf_attach);
+		goto err_put;
+	}
+	args.dir = PCIE_DMABUF_DIR_BIDIR;
+	switch (args.dir) {
+	case PCIE_DMABUF_DIR_BIDIR:
+		dir = DMA_BIDIRECTIONAL;
+		break;
+	case PCIE_DMABUF_DIR_TO_DEV:
+		dir = DMA_TO_DEVICE;
+		break;
+	case PCIE_DMABUF_DIR_FROM_DEV:
+		dir = DMA_FROM_DEVICE;
+		break;
+	default:
+		/* Not needed with check. Just here for any future change  */
+		dev_err(this->dma_dev, "invalid direction\n");
+		ret = -EINVAL;
+		goto err_detach;
+	}
+
+	sgt = dma_buf_map_attachment(dbuf_attach, dir);
+	if (IS_ERR(sgt)) {
+		dev_err(this->dma_dev, "failed to get dmabuf scatterlist\n");
+		ret = PTR_ERR(sgt);
+		goto err_detach;
+	}
+/* Accept only contiguous one */
+	if (sgt->nents != 1) {
+			printk("$$$$$$$$$$$$$$$$ nents  \n");
+		dma_addr_t next_addr = sg_dma_address(sgt->sgl);
+		struct scatterlist *s;
+		unsigned int i;
+
+		for_each_sg(sgt->sgl, s, sgt->nents, i) {
+			printk("$$$$$$$$$$$$$$$$ looping \n");
+			if (!sg_dma_len(s))
+				continue;
+
+			if (sg_dma_address(s) != next_addr) {
+				dev_err(this->dma_dev,
+					"dmabuf not contiguous\n");
+				ret = -EINVAL;
+				goto err_unmap;
+			}
+
+			next_addr = sg_dma_address(s) + sg_dma_len(s);
+		}
+	}
+	this->write_phys_addr = sg_dma_address(sgt->sgl);
+	}
+	else if(args.flag == 0) {
+	dma_buf_unmap_attachment(dbuf_attach,sgt,args.dir);
+	dma_buf_detach(dbuf,dbuf_attach);
+	dma_buf_put(dbuf);
+	}
+	return 0;
+
+err_free:
+	kfree(dbuf_mem);
+err_unmap:
+	dma_buf_unmap_attachment(dbuf_attach, sgt, dir);
+err_detach:
+	dma_buf_detach(dbuf, dbuf_attach);
+err_put:
+	dma_buf_put(dbuf);
+err:
+       return ret;
+}
 static int  pciep_direct_copy(struct pciep_driver_data *this, char __user *argp)
 {
         int ret = 0;
@@ -573,6 +699,10 @@ static long pciep_driver_file_ioctl(struct file *file, unsigned int cmd,
 			res.height = (value>>HEIGHT_SHIFT) & HEIGHT_MASK;
 			ret = copy_to_user((struct resolution *) arg, &res, sizeof(res));
 			return ret;
+	case GET_HDMI_PID :
+			value = reg_read(this, PCIRC_PID_SET);
+                        ret = copy_to_user((u32 *) arg, &value, sizeof(value));
+                        return ret;
 
 	case SET_READ_OFFSET:
 			ret = copy_from_user(&value1, (u64 *) arg, sizeof(value1));
@@ -609,17 +739,22 @@ static long pciep_driver_file_ioctl(struct file *file, unsigned int cmd,
 			return 0;
 
 	case GET_FPS:
-			value = reg_read(this, PCIRC_USECASE_MODE);
-			value = (value >> FPS_SHIFT) & FPS_MASK;
+			value = reg_read(this, PCIRC_SET_FPS);
 			ret = copy_to_user((u32 *) arg, &value, sizeof(value));
 			return ret;
 
 	case GET_FORMAT:
-			value = reg_read(this, PCIRC_USECASE_MODE);
-			value = (value >> FORMAT_SHIFT) & FORMAT_MASK;
+			value = reg_read(this, PCIRC_FORMAT_SET);
 			ret = copy_to_user((u32 *) arg, &value, sizeof(value));
 			return ret;
-	
+	case GET_USE_CASE:
+                        value = reg_read(this, PCIRC_UCASE_SET);
+                        ret = copy_to_user((u32 *) arg, &value, sizeof(value));
+                        return ret;
+	case GET_KERNEL_NAME:
+                        value = reg_read(this, PCIEP_KERNEL_NAME);
+                        ret = copy_to_user((u32 *) arg, &value, sizeof(value));
+                        return ret;
 	case ALLOC_DMA_BUFF:
 			ret = pciep_dmabuf_alloc(this, argp);
 			return ret;
@@ -630,6 +765,9 @@ static long pciep_driver_file_ioctl(struct file *file, unsigned int cmd,
 	case DIRECT_COPY:
                         ret = pciep_direct_copy(this, argp);
                         return ret; 
+	case PCIE_DMABUF_IMPORT:
+                        ret = pciep_dmabuf_import(this, argp);
+                        return ret; 
 	default:
 		return -ENOTTY;
 	}
-- 
2.17.1

