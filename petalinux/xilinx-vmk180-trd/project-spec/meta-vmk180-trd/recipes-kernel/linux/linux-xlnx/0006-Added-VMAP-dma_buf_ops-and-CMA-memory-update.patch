From d0d4dc6eb9b202a9792929256bafbaebab187042 Mon Sep 17 00:00:00 2001
From: thippesw <thippesw@xilinx.com>
Date: Mon, 9 May 2022 01:14:12 +0530
Subject: [PATCH] Added VMAP dma_buf_ops and CMA memory update

---
 drivers/misc/xilinx_pci_endpoint.c | 291 +++++++++++++++++++------------------
 1 file changed, 150 insertions(+), 141 deletions(-)

diff --git a/drivers/misc/xilinx_pci_endpoint.c b/drivers/misc/xilinx_pci_endpoint.c
index 2d52751..87babb3 100644
--- a/drivers/misc/xilinx_pci_endpoint.c
+++ b/drivers/misc/xilinx_pci_endpoint.c
@@ -48,129 +48,95 @@
 #include <linux/dma-mapping.h>
 #include <asm/page.h>
 #include <asm/byteorder.h>
+#include <linux/of_reserved_mem.h>
 
 #define DEVICE_MAX_NUM      256
 #define MAX_INSTANCES	    4
 #define DRIVER_NAME        "pciep"
 #define DEVICE_NAME_FORMAT "pciep%d"
 
-#define PCIEP_READ_BUFFER_READY   0x00
-#define PCIEP_READ_BUFFER_ADDR   0x04
-#define PCIEP_READ_BUFFER_OFFSET 0x08
-#define PCIEP_READ_BUFFER_SIZE   0x0c
-#define PCIEP_WRITE_BUFFER_READY   0x10
-#define PCIEP_WRITE_BUFFER_ADDR   0x14
-#define PCIEP_WRITE_BUFFER_OFFSET 0x18
-#define PCIEP_WRITE_BUFFER_SIZE   0x1c
-#define PCIEP_READ_TRANSFER_DONE   0x20
-#define PCIEP_WRITE_TRANSFER_DONE  0x24
-#define PCIEP_READ_TRANSFER_CLR    0x28
-#define PCIEP_READ_BUFFER_HOST_INTR  0x2c
-#define PCIEP_WRITE_TRANSFER_CLR  0x30
-#define PCIEP_KERNEL_NAME  0x3c
-
-#define PCIRC_READ_FILE_LENGTH     0x40
-#define PCIRC_READ_BUFFER_TRANSFER_DONE 0x44
-#define PCIRC_WRITE_BUFFER_TRANSFER_DONE 0x48
-#define PCIRC_PID_SET 				0x4c
-#define PCIRC_KERNEL_MODE	      		0x60
-#define PCIRC_FILTER_TYPE         0x50
-#define PCIRC_RAW_RESOLUTION      0x54
-#define PCIRC_FORMAT_SET        0x58
-#define PCIRC_UCASE_SET       0x5c
-#define PCIRC_SET_FPS        0x64
-#define PCIRC_READ_BUFFER_TRANSFER_DONE_INTR 0x68
-#define PCIRC_WRITE_BUFFER_TRANSFER_DONE_INTR 0x6c
-#define PCIRC_HOST_DONE_INTR     0x70
-#define PCIRC_READ_SIG  	0x74
-
-#define PCIEP_CLR_REG            0x0
-#define CLR_ALL                  0x0
-#define CLR_BUFFER_RDY           0x0
-#define SET_BUFFER_RDY           0x1
-#define SET_TRANSFER_DONE        0x1
-
-#define GET_FILE_LENGTH			  0x0
-#define GET_KERNEL_MODE  		  0x1
-#define SET_READ_OFFSET 		  0x2
-#define SET_WRITE_OFFSET		  0x3
-#define SET_READ_TRANSFER_DONE    0x5
-#define CLR_READ_TRANSFER_DONE    0x6
-#define SET_WRITE_TRANSFER_DONE   0x7
-#define CLR_WRITE_TRANSFER_DONE   0x8
-#define GET_RESOLUTION            0x9
-#define GET_HDMI_PID              0xa
-#define GET_FPS                   0xb
-#define GET_FORMAT                0xc
-#define GET_FILTER_TYPE           0xd
-#define ALLOC_DMA_BUFF            0xe
-#define RELEASE_DMA_BUFF          0xf
-#define PCIE_DMABUF_IMPORT        0x1b
-#define GET_KERNEL_NAME        	  0x1c
-#define GET_USE_CASE        	  0x1d
-
-#define MAP_DMA_BUFF		  0x1e
-#define UNMAP_DMA_BUFF            0x1f
-#define READ_SIG		  0x20
-#define WIDTH_SHIFT               0x0
-#define WIDTH_MASK                0xFFFF
-#define HEIGHT_SHIFT              16
-#define HEIGHT_MASK               0xFFFF
-#define USE_CASE_MODE_SHIFT       0x0
-#define USE_CASE_MODE_MASK        0x3
-#define FPS_SHIFT                 0x5
-#define FPS_MASK                  0x3FF
-#define FORMAT_SHIFT              0x2
-#define FORMAT_MASK               0x7
-
-#define L2CACHE_SHIFT             0x0
-#define L2CACHE_MASK		      0x1
-#define LOW_BANDWIDTH_SHIFT       0x1
-#define LOW_BANDWIDTH_MASK	      0x1
-#define FILLER_DATA_SHIFT		  0x2
-#define FILLER_DATA_MASK		  0x1
-#define BITRATE_SHIFT			  0x4
-#define BITRATE_MASK			  0xFFFF
-#define GOP_LENGTH_SHIFT		  20
-#define GOP_LENGTH_MASK			  0xFFF
-
-#define B_FRAME_SHIFT			  0x0
-#define B_FRAME_MASK			  0x3
-#define SLICE_SHIFT				  0x3
-#define SLICE_MASK				  0x3F
-#define QP_MODE_SHIFT			  0x9
-#define QP_MODE_MASK			  0x3
-#define RC_MODE_SHIFT			  0xb
-#define RC_MODE_MASK			  0x3
-#define ENC_TYPE_SHIFT			  0xd
-#define ENC_TYPE_MASK			  0x3
-#define GOP_MODE_SHIFT			  0xf
-#define GOP_MODE_MASK			  0x3
-#define PROFILE_SHIFT			  0x12
-#define PROFILE_MASK			  0x3
-#define LATENCY_MODE_SHIFT		  0x15
-#define LATENCY_MODE_MASK		  0x3
-
+/* PCIe registers to perform file read */
+#define PCIEP_READ_BUFFER_READY   		0x00
+#define PCIEP_READ_BUFFER_ADDR_LOW   		0x04
+#define PCIEP_READ_BUFFER_OFFSET 		0x08
+#define PCIEP_READ_BUFFER_SIZE   		0x0c
+#define PCIEP_READ_BUFFER_ADDR_HIGH   		0x3c
+#define PCIEP_READ_TRANSFER_DONE   		0x20
+#define PCIEP_READ_TRANSFER_CLR    		0x28
+#define PCIEP_READ_BUFFER_HOST_INTR 		0x2c
+
+/* PCIe registers to perfrom file write */
+#define PCIEP_WRITE_BUFFER_READY   		0x10
+#define PCIEP_WRITE_BUFFER_ADDR_LOW   		0x14
+#define PCIEP_WRITE_BUFFER_OFFSET 		0x18
+#define PCIEP_WRITE_BUFFER_SIZE   		0x1c
+#define PCIEP_WRITE_TRANSFER_DONE  		0x24
+#define PCIEP_WRITE_TRANSFER_CLR  		0x30
+#define PCIEP_WRITE_BUFFER_ADDR_HIGH   		0x38
+
+
+/* HOST PARAMETERS INFO */
+#define PCIRC_READ_FILE_LENGTH     		0x84
+#define PCIRC_READ_BUFFER_TRANSFER_DONE 	0x88
+#define PCIRC_WRITE_BUFFER_TRANSFER_DONE 	0x8c
+#define PCIRC_HDMI_PID_SET 			0x90
+#define PCIRC_FILTER_TYPE         		0x94
+#define PCIRC_RAW_RESOLUTION      		0x98
+#define PCIRC_FORMAT_SET        		0x9c
+#define PCIRC_UCASE_SET       			0xa0
+#define PCIRC_KERNEL_MODE	      		0xa4
+#define PCIRC_SET_FPS        			0xa8
+#define PCIEP_FILTER_KERNEL_NAME  		0xac
+#define PCIRC_READ_SIG  			0xb4
+
+/* Interrupt registers to interrupt ps from host machine */
+#define PCIRC_READ_BUFFER_TRANSFER_DONE_INTR 	0xf0
+#define PCIRC_WRITE_BUFFER_TRANSFER_DONE_INTR 	0xf4 
+#define PCIRC_HOST_DONE_INTR			0xf8 
+
+/* Macro's to mask PCIe registers */
+#define PCIEP_CLR_REG            	0x0
+#define CLR_ALL                  	0x0
+#define CLR_BUFFER_RDY           	0x0
+#define SET_BUFFER_RDY           	0x1
+#define SET_TRANSFER_DONE        	0x1
+
+/* IOCTL numbers */ 
+#define GET_FILE_LENGTH			0x0
+#define GET_KERNEL_MODE			0x1
+#define SET_READ_OFFSET			0x2
+#define SET_WRITE_OFFSET		0x3
+#define SET_READ_TRANSFER_DONE    	0x5
+#define CLR_READ_TRANSFER_DONE    	0x6
+#define SET_WRITE_TRANSFER_DONE   	0x7
+#define CLR_WRITE_TRANSFER_DONE   	0x8
+#define GET_RESOLUTION            	0x9
+#define GET_HDMI_PID              	0xa
+#define GET_FPS                   	0xb
+#define GET_FORMAT                	0xc
+#define GET_FILTER_TYPE           	0xd
+#define ALLOC_DMA_BUFF            	0xe
+#define RELEASE_DMA_BUFF          	0xf
+#define PCIE_DMABUF_IMPORT        	0x1b
+#define GET_KERNEL_NAME        	  	0x1c
+#define GET_USE_CASE        	  	0x1d
+#define MAP_DMA_BUFF		  	0x1e
+#define UNMAP_DMA_BUFF            	0x1f
+#define READ_SIG		  	0x20
+#define NUM_DMA_BUF		  	0x21
+
+/* Macro's used for masking resoltion */
+#define WIDTH_SHIFT               	0x0
+#define WIDTH_MASK                	0xFFFF
+#define HEIGHT_SHIFT              	16
+#define HEIGHT_MASK               	0xFFFF
+
+/*Macro's used for masking offset */
 #define READ_BUF_HIGH_OFFSET      0xFFFF0000
 #define WRITE_BUF_HIGH_OFFSET     0xFFFF0000
+
 #define NUM_BUFFERS		3
 
-int active_index;
-/**
- * _PGPROT_NONCACHED    : vm_page_prot value when ((sync_mode & SYNC_MODE_MASK)
- *			== SYNC_MODE_NONCACHED)
- * _PGPROT_WRITECOMBINE : vm_page_prot value when ((sync_mode & SYNC_MODE_MASK)
- *			== SYNC_MODE_WRITECOMBINE)
- * _PGPROT_DMACOHERENT  : vm_page_prot value when ((sync_mode & SYNC_MODE_MASK)
- *			== SYNC_MODE_DMACOHERENT )
- */
-#if defined(CONFIG_ARM)
-#define _PGPROT_NONCACHED(vm_page_prot)    pgprot_noncached(vm_page_prot)
-#elif defined(CONFIG_ARM64)
-#define _PGPROT_NONCACHED(vm_page_prot)    pgprot_writecombine(vm_page_prot)
-#else
-#define _PGPROT_NONCACHED(vm_page_prot)    pgprot_noncached(vm_page_prot)
-#endif
 char *fd_names[NUM_BUFFERS] = {
 	"fd1",
 	"fd2",
@@ -262,7 +228,9 @@ struct pciep_driver_data {
 	int host_done_irq;
 	int read_req;
     	int fd[NUM_BUFFERS];	/* fd */
-   	int fd_inuse[NUM_BUFFERS]
+   	int fd_inuse[NUM_BUFFERS];
+	int num_dma_buf;
+	int active_index;
 };
 
 struct pciep_alloc_dma_buf {
@@ -452,7 +420,6 @@ static int pciep_mmap(struct dma_buf *dmabuf,
 			struct vm_area_struct *vma)
 {
 	struct pciep_driver_data *this = dmabuf->priv;
-	size_t size = vma->vm_end - vma->vm_start;
 	void *virt;
 	dma_addr_t phys;
 
@@ -496,7 +463,7 @@ static int pciep_dmabuf_import(struct pciep_driver_data *this,
 		dbuf = dma_buf_get(args.dbuf_fd);
 		if (IS_ERR(dbuf)) {
 			dev_err(this->dma_dev, "failed to get dmabuf\n");
-			ret -1;
+			ret = -1;
 			goto err;
 		}
 		dbuf_attach = dma_buf_attach(dbuf, this->dma_dev);
@@ -607,7 +574,7 @@ static int pciep_dmabuf_free(struct pciep_driver_data *this, char __user *argp)
 	dma_addr_t phys;
 	int i;
 
-	for (i = 0; i < NUM_BUFFERS; i++) {
+	for (i = 0; i < this->num_dma_buf; i++) {
 		virt = this->read_virt_addr[i];
 		phys = this->read_phys_addr[i];
 		dma_free_coherent(this->dma_dev, this->alloc_size,
@@ -621,6 +588,14 @@ static void pciep_release(struct dma_buf *dmabuf)
 {
 
 }
+static int pciep_dma_buf_vmap(struct dma_buf *dmabuf, struct dma_buf_map *map)
+{
+	struct pciep_driver_data *this = dmabuf->priv;
+
+	dma_buf_map_set_vaddr(map, this->read_virt_addr[this->active_index]);
+
+	return 0;
+}
 
 static const struct dma_buf_ops pciep_dma_buf_ops = {
 	.attach = pciep_dma_buf_attach,
@@ -628,6 +603,7 @@ static void pciep_release(struct dma_buf *dmabuf)
 	.map_dma_buf = pciep_map_dma_buf,
 	.unmap_dma_buf = pciep_unmap_dma_buf,
 	.mmap = pciep_mmap,
+	.vmap = pciep_dma_buf_vmap,
 	.release = pciep_release,
 };
 
@@ -643,19 +619,19 @@ static int pciep_dmabuf_map(struct pciep_driver_data *this, char __user *argp)
 	int i; 
 	int fd;
 
-	for (i = 0; i < NUM_BUFFERS; i++) {
+	for (i = 0; i < this->num_dma_buf; i++) {
 		if (!this->fd_inuse[i]) {
 			fd = this->fd[i];
 			this->fd_inuse[i] = 1;
 			/* Flag to assign array of read phys addre */
-			active_index = i;
+			this->active_index = i;
 			break;
 		}
 	}
-	/* if i == NUM_BUFFERS, it means all buffers are used
+	/* if i == num_dma_buf, it means all buffers are used
 	 * so return error.
 	 */
-	if (i == NUM_BUFFERS) {
+	if (i == this->num_dma_buf) {
 		return -EFAULT;
 	}
 
@@ -681,7 +657,7 @@ static int pciep_dmabuf_unmap(struct pciep_driver_data *this, char __user *argp)
 	if (copy_from_user(&bp, argp, sizeof(bp)))
 		return -EFAULT;
 	
-	for (i = 0; i < NUM_BUFFERS; i++) {
+	for (i = 0; i < this->num_dma_buf; i++) {
 		if (this->fd[i] == bp.fd) {
 			this->fd_inuse[i] = 0;
 			break;
@@ -700,7 +676,6 @@ static int pciep_dmabuf_alloc(struct pciep_driver_data *this, char __user *argp)
 {
 	struct pciep_alloc_dma_buf bp;
 	struct dma_buf_export_info exp_info[3] = { };
-	int err;
 	int i,j;
 	void *virt;
 	dma_addr_t phys;
@@ -711,7 +686,7 @@ static int pciep_dmabuf_alloc(struct pciep_driver_data *this, char __user *argp)
 		return -EFAULT;
 
 	/* allocate read buffer */
-	for (i = 0; i < NUM_BUFFERS; i++) {
+	for (i = 0; i < this->num_dma_buf; i++) {
 		virt = dma_alloc_coherent(this->dma_dev, bp.size,
 				&phys, GFP_KERNEL);
 		if (IS_ERR_OR_NULL(virt)) {
@@ -753,16 +728,16 @@ static int pciep_dmabuf_alloc(struct pciep_driver_data *this, char __user *argp)
 err_export:
 	virt = this->read_virt_addr[i];
 	phys = this->read_phys_addr[i];
-	this->read_virt_addr[i] = NULL;
-	this->read_phys_addr[i] = NULL;
+	this->read_virt_addr[i] = 0;
+	this->read_phys_addr[i] = 0;
 	dma_free_coherent(this->dma_dev, this->alloc_size,
 			virt, phys);
 err_alloc:
 	for (j = i-1; j >= 0; j--) {
 		virt = this->read_virt_addr[j];
 		phys = this->read_phys_addr[j];
-		this->read_virt_addr[j] = NULL;
-		this->read_phys_addr[j] = NULL;
+		this->read_virt_addr[j] = 0;
+		this->read_phys_addr[j] = 0;
 		dma_free_coherent(this->dma_dev, this->alloc_size,
 				virt, phys);
 	}
@@ -807,7 +782,7 @@ static long pciep_driver_file_ioctl(struct file *file, unsigned int cmd,
 			return ret;
 	
 	case GET_HDMI_PID :
-	    		value = reg_read(this, PCIRC_PID_SET);
+	    		value = reg_read(this, PCIRC_HDMI_PID_SET);
 	    		ret = copy_to_user((u32 *) arg, &value, sizeof(value));
 	    		return ret;
 
@@ -861,7 +836,7 @@ static long pciep_driver_file_ioctl(struct file *file, unsigned int cmd,
 	   		return ret;
 
 	case GET_KERNEL_NAME:
-	   		value = reg_read(this, PCIEP_KERNEL_NAME);
+	   		value = reg_read(this, PCIEP_FILTER_KERNEL_NAME);
 	   		ret = copy_to_user((u32 *) arg, &value, sizeof(value));
 	   		return ret;
 
@@ -889,6 +864,12 @@ static long pciep_driver_file_ioctl(struct file *file, unsigned int cmd,
 	   		value = reg_read(this, PCIRC_READ_SIG);
 			ret = copy_to_user((u32 *) arg, &value, sizeof(value));
 	   		return ret;
+
+	case NUM_DMA_BUF:
+                        ret = copy_from_user(&value1, (u64 *) arg, sizeof(value1));
+			this->num_dma_buf = value1;
+                        return ret;
+
  
 	default:
 			return -ENOTTY;
@@ -909,14 +890,20 @@ static ssize_t pciep_driver_file_read(struct file *file, char __user *buff,
 	struct pciep_driver_data *this = file->private_data;
 	u32 value;
 	int ret = 0;
-
+	u32 read_phys;
 	/* check the size */
 	if (count <= 0)
 		return -EINVAL;
-    reg_write(this, PCIEP_READ_BUFFER_ADDR, this->read_phys_addr[active_index]);
-    reg_write(this, PCIEP_READ_BUFFER_SIZE, count);
-    value = reg_read(this, PCIEP_READ_BUFFER_READY);
-    value |= SET_BUFFER_RDY;
+	
+	read_phys = this->read_phys_addr[this->active_index] >> 32;	
+    	reg_write(this, PCIEP_READ_BUFFER_ADDR_HIGH, read_phys);
+    	
+	read_phys = this->read_phys_addr[this->active_index] ;	
+    	reg_write(this, PCIEP_READ_BUFFER_ADDR_LOW,read_phys );
+
+	reg_write(this, PCIEP_READ_BUFFER_SIZE, count);
+	value = reg_read(this, PCIEP_READ_BUFFER_READY);
+    	value |= SET_BUFFER_RDY;
     reg_write(this, PCIEP_READ_BUFFER_READY, value);
 
 	/* wait for done event */
@@ -940,12 +927,17 @@ static ssize_t pciep_driver_file_write(struct file *file,
 	struct pciep_driver_data *this = file->private_data;
 	int ret = 0;
 	u32 value;
-
+	u32 write_phys;
 	/* check the size */
 	if (count <= 0)
 		return -EINVAL;
-
-	reg_write(this, PCIEP_WRITE_BUFFER_ADDR, this->write_phys_addr);
+    	
+	
+	write_phys = this->write_phys_addr >> 32;	
+	reg_write(this, PCIEP_WRITE_BUFFER_ADDR_HIGH, write_phys);
+    	write_phys = this->write_phys_addr;	
+	reg_write(this, PCIEP_WRITE_BUFFER_ADDR_LOW,write_phys);
+	
 	reg_write(this, PCIEP_WRITE_BUFFER_SIZE, count);
 	value = reg_read(this, PCIEP_WRITE_BUFFER_READY);
 	value |= SET_BUFFER_RDY;
@@ -1102,9 +1094,9 @@ static struct pciep_driver_data *pciep_driver_create(const char *name,
 	this->dma_dev = parent;
 
 	of_dma_configure(this->dma_dev, NULL, true);
-	dma_set_mask(this->dma_dev, DMA_BIT_MASK(sizeof(dma_addr_t) * 4));
+	dma_set_mask(this->dma_dev, DMA_BIT_MASK(64));
 	dma_set_coherent_mask(this->dma_dev,
-			      DMA_BIT_MASK(sizeof(dma_addr_t) * 4));
+		      DMA_BIT_MASK(64));
 
 	done |= DONE_ALLOC_CMA;
 
@@ -1152,7 +1144,6 @@ static int pciep_platform_driver_probe(struct platform_device *pdev)
 	struct pciep_driver_data *driver_data;
 	struct device_node *node = pdev->dev.of_node;
 	struct resource *res;
-	int status;
 	int ret;
 	u32 size=4096;
 	char channel[5];
@@ -1212,6 +1203,13 @@ static int pciep_platform_driver_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "Unable to register IRQ\n");
 		goto failed;
 	}
+	/* Initialize reserved memory resources */
+  	 ret = of_reserved_mem_device_init(&pdev->dev);
+ 	if(ret) {
+    		dev_err(&pdev->dev, "Could not get reserved memory\n");
+    		goto failed;
+  	} 
+	
 	dev_set_drvdata(&pdev->dev, driver_data);
 	dev_info(&pdev->dev, "pcie driver probe success.\n");
 	return 0;
@@ -1295,6 +1293,16 @@ static void __exit pciep_module_exit(void)
 }
 
 /**
+* pciep_devnode() - To provide permissions to non-root user
+*/
+static char *pciep_devnode(struct device *dev, umode_t *mode)
+{
+       if (mode)
+          *mode = 0666; /* or whatever permissions you want */
+       return NULL; /* could override /dev name here too */
+}
+
+/**
  * pciep_module_init()
  */
 static int __init pciep_module_init(void)
@@ -1317,6 +1325,7 @@ static int __init pciep_module_init(void)
 		pciep_sys_class = NULL;
 		goto failed;
 	}
+	pciep_sys_class->devnode = pciep_devnode;
 	retval = platform_driver_register(&pciep_platform_driver);
 	if (retval)
 		pr_err("%s: couldn't register platform driver\n", DRIVER_NAME);
-- 
1.8.3.1

